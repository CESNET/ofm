<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UVM Verification &mdash; OFM User Guide 1.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Byte Array agent" href="byte_array/readme.html" />
    <link rel="prev" title="Verifications" href="../../ver.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> OFM User Guide
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Build system:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../build/readme.html">Build System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Components:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../base.html">Basic Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ctrls.html">Controllers &amp; TSU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fl.html">FL Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../flu.html">FLU Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mi.html">MI Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mfb.html">MFB Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mvb.html">MVB Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nic.html">Network Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcie.html">PCIe Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../debug.html">Debug Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../ver.html">Verifications</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">UVM Verification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="byte_array/readme.html">Byte Array agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="byte_array_lii/readme.html">Byte Array to LII convert enviroment</a></li>
<li class="toctree-l3"><a class="reference internal" href="byte_array_pma/readme.html">Byte array to pma convert enviroment</a></li>
<li class="toctree-l3"><a class="reference internal" href="common/readme.html">COMMON PACKAGE</a></li>
<li class="toctree-l3"><a class="reference internal" href="lii/readme.html">LII agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="mvb/readme.html">MVB agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="mi/readme.html">UVM MI agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="pma/readme.html">PMA agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset/readme.html">RESET agent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systemverilog-and-uvm-tutorial">SystemVerilog and UVM tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-usage-of-uvm-methodology-in-ofm">Basic usage of UVM methodology in OFM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interface">Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#properties">Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver">Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#agent">Agent</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-object">Configuration object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sequence">Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sequence-library">Sequence library</a></li>
<li class="toctree-l4"><a class="reference internal" href="#package">Package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#layered-agents">Layered agents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#environment">Environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#low-level-sequence">Low level sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#high-level-monitor">High level monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Configuration object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">Sequence library</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-of-the-specific-sequence">Run of the specific sequence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#common-environment">Common environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#virtual-sequencer">Virtual sequencer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scoreboard">Scoreboard</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#request-response-agents">Request response Agents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reset">Reset</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#monitor">Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sequencer-and-sequence">Sequencer and sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model">Model</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#coverage">Coverage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functional-coverage">Functional coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-coverage">Code coverage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#verification-example">Verification example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#byte-array-port-environment">Byte_array_port environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">Scoreboard</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-environment">Test environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test">Test</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testbench">testbench</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#notes">NOTES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#uvm-error-vs-uvm-fatal">UVM_error vs UVM_fatal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parametrized-object">Parametrized object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization">Synchronization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ofm-verification-environment">OFM verification environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#modules-tcl">Modules.tcl</a></li>
<li class="toctree-l4"><a class="reference internal" href="#main-fdo-script-for-running-the-verification">Main .fdo script for running the verification</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packages:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../base/pkg/readme.html">Packages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OFM User Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../ver.html">Verifications</a> &raquo;</li>
      <li>UVM Verification</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/comp/uvm/readme.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="uvm-verification">
<span id="uvm-ver"></span><h1>UVM Verification<a class="headerlink" href="#uvm-verification" title="Permalink to this headline"></a></h1>
<p>New verifications should be written in UVM methodology. This directory contains common agents and environments. Only the highly specified code such as model should be in directory with component.</p>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Components:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="byte_array/readme.html">Byte Array agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="byte_array/readme.html#byte-array-sequence-item">Byte Array sequence item</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="byte_array_lii/readme.html">Byte Array to LII convert enviroment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="byte_array_lii/readme.html#byte-array-to-lii-monitor">Byte Array to LII monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="byte_array_lii/readme.html#byte-array-to-lii-sequence">Byte Array to LII Sequence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="byte_array_pma/readme.html">Byte array to pma convert enviroment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="byte_array_pma/readme.html#byte-array-to-pma-monitor">Byte Array to PMA monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="byte_array_pma/readme.html#byte-array-to-pma-sequence">Byte Array to PMA Sequence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="common/readme.html">COMMON PACKAGE</a><ul>
<li class="toctree-l2"><a class="reference internal" href="common/readme.html#random">Random</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lii/readme.html">LII agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lii/readme.html#lii-interface">LII interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="lii/readme.html#lii-sequence-item">LII sequence item</a></li>
<li class="toctree-l2"><a class="reference internal" href="lii/readme.html#lii-monitor">LII monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="lii/readme.html#lii-driver">LII driver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mvb/readme.html">MVB agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#interface">Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#sequence-item">Sequence item</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#sequence">Sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#driver">Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#monitor">Monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#config">Config</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvb/readme.html#agent">Agent</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mi/readme.html">UVM MI agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mi/readme.html#sequence-item">Sequence_item</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pma/readme.html">PMA agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pma/readme.html#pma-interface">PMA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pma/readme.html#pma-sequence-item">PMA sequence item</a></li>
<li class="toctree-l2"><a class="reference internal" href="pma/readme.html#pma-monitor">PMA monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="pma/readme.html#pma-driver">PMA driver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reset/readme.html">RESET agent</a><ul>
<li class="toctree-l2"><a class="reference internal" href="reset/readme.html#simple-sychronous-reset-agents">simple sychronous RESET agents</a></li>
</ul>
</li>
</ul>
</div>
<section id="systemverilog-and-uvm-tutorial">
<h2>SystemVerilog and UVM tutorial<a class="headerlink" href="#systemverilog-and-uvm-tutorial" title="Permalink to this headline"></a></h2>
<p>This documents describes how should be written the UVM verification of our components. This is not UVM or SystemVerilog manual. UVM tutorials you can find on folowing links</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.asic-world.com/systemverilog/tutorial.html">systemverilog tutorial</a></p></li>
<li><p><a class="reference external" href="https://verificationguide.com/uvm/uvm-tutorial/">UVM tutorial</a></p></li>
<li><p><a class="reference external" href="https://www.accellera.org/images/downloads/standards/uvm/uvm_users_guide_1.2.pdf">UVM user guide</a></p></li>
<li><p><a class="reference external" href="https://www.doulos.com/media/1277/easier-uvm-coding-guidelines-2016-06-24.pdf">Doulos coding guidelines</a></p></li>
<li><p><a class="reference external" href="https://www.amiq.com/consulting/2017/05/29/how-to-pack-data-using-systemverilog-streaming-operators/">Packing</a></p></li>
<li><p><a class="reference external" href="https://www.amiq.com/consulting/2017/06/23/how-to-unpack-data-using-the-systemverilog-streaming-operators/">Unpacking</a></p></li>
<li><p><a class="reference external" href="http://www.asic-world.com/systemverilog/assertions.html">systemverilog Assertion</a></p></li>
<li><p><a class="reference external" href="https://www.einfochips.com/blog/system-verilog-assertions-simplified/">systemverilog Assertion</a></p></li>
</ul>
</section>
<section id="basic-usage-of-uvm-methodology-in-ofm">
<h2>Basic usage of UVM methodology in OFM<a class="headerlink" href="#basic-usage-of-uvm-methodology-in-ofm" title="Permalink to this headline"></a></h2>
<p>This document describes solution of some common verification problems. This documents doesn’t have to describe best solution, but it describe best solution what we find out.</p>
<section id="interface">
<h3>Interface<a class="headerlink" href="#interface" title="Permalink to this headline"></a></h3>
<p>Interface connects DUT with test. In interface is required to use <strong>wire logic</strong> instead of <strong>logic</strong> if there is no strong reason to do otherwise. <strong>Wire logic</strong> is net but <strong>logic</strong> is variable.
Reason of this solution is fact that we want to use one interface for RX and TX comunication. If you want to know more visit <a class="reference external" href="https://blogs.sw.siemens.com/verificationhorizons/2013/05/03/wire-vs-reg/">wire logic vs logic</a>
It is required to use clocking block in interface if there is no strong reason to do otherwise.
Also interfaces dosn’t have namespaces. This means that interfaces must have unique names.</p>
</section>
<section id="properties">
<h3>Properties<a class="headerlink" href="#properties" title="Permalink to this headline"></a></h3>
<p>DUT comunicate with surroundings by some protocols which can have some restristions. These restriction can be controlled by module properties
which can be instantiate and connect to interface. Module then control if DUT keeps rules of these comunication protocol.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span> <span class="n">mfb_properties</span> <span class="p">(</span><span class="k">input</span> <span class="k">logic</span> <span class="no">RESET</span><span class="p">,</span> <span class="n">mfb_if</span> <span class="no">RX_MFB</span><span class="p">);</span>
    <span class="k">property</span> <span class="n">prop_rdy</span><span class="p">;</span>
        <span class="p">(</span><span class="k">posedge</span> <span class="no">RX_FB</span><span class="p">.</span><span class="no">CLK</span><span class="p">)</span> <span class="k">disable</span> <span class="k">iff</span><span class="p">(</span><span class="no">RESET</span> <span class="o">==</span> <span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">)</span>
        <span class="o">!</span><span class="n">$isunknown</span><span class="p">(</span><span class="no">MFB_IF</span><span class="p">.</span><span class="no">DST_RDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">$isunknown</span><span class="p">(</span><span class="no">MFB_IF</span><span class="p">.</span><span class="no">SRC_RDY</span><span class="p">);</span>
    <span class="k">endproperty</span>

    <span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="n">prop_rdy</span><span class="p">)</span> <span class="k">else</span> <span class="k">begin</span> <span class="no">`uvm_fatal</span><span class="p">(</span><span class="s">&quot;MFB INTERFACE: src and dst rdy have to be always valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="k">end</span>
<span class="k">endmodule</span>
</pre></div>
</div>
</section>
<section id="driver">
<h3>Driver<a class="headerlink" href="#driver" title="Permalink to this headline"></a></h3>
<p>Driver writes data to interface. It is required to use function <strong>try_get</strong> or <strong>try_next_item</strong> to get next item. Do not use function <strong>get</strong> or <strong>get_next_item</strong>.
If some sequencer uses for example wait <em>#(4ns)</em>, it can desynchronize driver with clocking block and race condition can happen.</p>
<p>Example of sequence with space 40ns space between sended items</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_simple</span> <span class="k">extends</span> <span class="n">uvm_sequence</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">pkg</span><span class="o">::</span><span class="n">sequence_simple</span><span class="p">)</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="n">taks</span> <span class="n">body</span> <span class="p">();</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">sequence_item</span><span class="o">::</span><span class="n">tpye_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;req&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="mh">10</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="n">req</span><span class="p">.</span><span class="n">randomize</span><span class="p">();</span>
            <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="p">#(</span><span class="mh">10</span><span class="p">)</span><span class="n">ns</span> <span class="c1">// this can desincronize driver and broke protocol. if task get is used instead of function try get.</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">driver</span> <span class="k">extends</span> <span class="n">uvm_driver</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_componet_utils</span><span class="p">(</span><span class="n">pkg</span><span class="o">::</span><span class="n">driver</span><span class="p">)</span>
    <span class="k">virtual</span> <span class="k">interface</span> <span class="n">vif</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="n">taks</span> <span class="n">run_phase</span> <span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="k">forever</span> <span class="k">begin</span>
            <span class="n">seq_item_port</span><span class="p">.</span><span class="n">try_next_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">begin</span>
                <span class="n">vif</span><span class="p">.</span><span class="n">cb</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">req</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
                <span class="n">seq_item_port</span><span class="p">.</span><span class="n">item_done</span><span class="p">();</span>
            <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
                <span class="n">vif</span><span class="p">.</span><span class="n">cb</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="m">&#39;x</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="p">@(</span><span class="n">vif</span><span class="p">.</span><span class="n">cb</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="agent">
<h3>Agent<a class="headerlink" href="#agent" title="Permalink to this headline"></a></h3>
<p>Pleas keep following rules for creating agents, enviroments and pakcage.</p>
<ol class="arabic simple">
<li><p>Use name of class together with package name in the UVM registation macro.</p></li>
<li><p>The name of class would be <em>monitor, driver, sequencer, config, sequence_item</em>. A suffix such as <em>_rx, _tx</em> can be used if required.</p></li>
<li><p>For the sequences, use <em>sequence_</em> prefix.</p></li>
<li><p>Variable names should have the prefix <em>m_</em>.</p></li>
<li><p>Files have the same name as class inside file. Every agent is placed into his own directory togeter with package <em>pkg.sv</em> and interface <em>interface.sv</em> if the interface is required</p></li>
</ol>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">agent</span> <span class="k">extends</span> <span class="n">uvm_agent</span><span class="p">;</span>
    <span class="no">`uvm_component_utils</span><span class="p">(</span> <span class="n">example</span><span class="o">::</span><span class="n">agent</span> <span class="p">)</span>
    <span class="n">uvm_analysis_port</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">analysis_port</span><span class="p">;</span>
    <span class="k">config</span> <span class="n">m_config</span><span class="p">;</span>
    <span class="n">sequencer</span> <span class="n">m_sequencer</span><span class="p">;</span>
    <span class="n">driver</span>    <span class="n">m_driver</span><span class="p">;</span>
    <span class="n">monitor</span>   <span class="n">m_monitor</span><span class="p">;</span>
    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">config</span><span class="p">)</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;m_config&quot;</span><span class="p">,</span> <span class="n">m_config</span><span class="p">))</span>
            <span class="no">`uvm_fatal</span><span class="p">(...);</span>
        <span class="c1">// First parametr name has to be same string as variable name</span>
        <span class="n">m_monitor</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_monitor&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">active</span> <span class="o">==</span> <span class="no">ACTIVE</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">m_driver</span>  <span class="o">=</span> <span class="n">driver</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_driver&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
            <span class="n">m_sequencer</span> <span class="o">=</span> <span class="n">sequencer</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_sequencer&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="k">virtual</span> <span class="n">axi_lite_interface</span> <span class="p">#(</span><span class="no">ADDR_WIDTH</span><span class="p">,</span> <span class="no">DATA_WIDTH</span><span class="p">)</span> <span class="n">vif</span><span class="p">;</span>
        <span class="k">super</span><span class="p">.</span><span class="n">connect_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">virtual</span> <span class="n">axi_lite_interface</span><span class="p">#(</span><span class="no">ADDR_WIDTH</span><span class="p">,</span> <span class="no">DATA_WIDTH</span><span class="p">))</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;interface&quot;</span><span class="p">,</span> <span class="n">vif</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span> <span class="k">begin</span>
            <span class="no">`uvm_fatal</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">get_full_name</span><span class="p">(),</span> <span class="s">&quot;Virtual interface axi_lite_interface havent been found.&quot;</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="n">m_monitor</span><span class="p">.</span><span class="n">vif</span> <span class="o">=</span> <span class="n">vif</span><span class="p">;</span>
        <span class="n">analysis_port</span> <span class="o">=</span> <span class="n">m_monitor</span><span class="p">.</span><span class="n">analysis_port</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="p">.</span><span class="n">active</span> <span class="o">==</span> <span class="no">ACTIVE</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">m_driver</span><span class="p">.</span><span class="n">vif</span> <span class="o">=</span> <span class="n">vif</span><span class="p">;</span>
            <span class="n">m_driver</span><span class="p">.</span><span class="n">seq_item_port</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m_sequencer</span><span class="p">.</span><span class="n">seq_item_export</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="configuration-object">
<h3>Configuration object<a class="headerlink" href="#configuration-object" title="Permalink to this headline"></a></h3>
<p>Every agent has his own configuration object, which can change agent behavioral.
There are two most common variables in the configuration object.
The first one is <em>active</em> which represents if the agent is active or passive. Active agent contain driver and it activly drive comunication on interface.
Passive agetnt is used just for observation of comunication on interface.
The second one is <em>interface_name</em> in case of direct communication between agent and DUT. Agent finds the correct interface in UVM configuration database save under <em>interface_name</em>.</p>
</section>
<section id="sequence">
<h3>Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline"></a></h3>
<p>The sequence contains three functions, which can change the randomization output (pre_do, mid_do, post_do).
Function pre_do is called before randomization. It is suitable for changing randomization rules.
Function mid_do is called after randomization and before the result is send to the driver.
This is suitable for setup of a specific value which could be difficult to randomize.
Function post_do is called after the driver processes transaction. It is suitable for generating statistic
or something else.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">config_sequence</span> <span class="k">extends</span> <span class="k">config</span><span class="o">::</span><span class="n">simple_simple</span><span class="p">;</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">seq</span><span class="o">::</span><span class="n">config_sequence</span><span class="p">)</span>
    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="n">pre_do</span><span class="p">(</span><span class="n">uvm_sequence_item</span> <span class="n">this_item</span><span class="p">);</span>
        <span class="c1">//this happen before randomization</span>
        <span class="n">this_item</span><span class="p">.</span><span class="n">size_max</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="mh">10</span><span class="p">;</span>
    <span class="k">endfunction</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="n">mid_do</span><span class="p">(</span><span class="n">uvm_sequence_item</span> <span class="n">this_item</span><span class="p">);</span>
        <span class="c1">//this happen after randomization</span>
        <span class="n">this_item</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="o">++</span><span class="p">;</span>
    <span class="k">endfunction</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="n">post_do</span><span class="p">(</span><span class="n">uvm_sequence_item</span> <span class="n">this_item</span><span class="p">);</span>
        <span class="c1">//this happen after sequence item has been processed</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">this_item</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="sequence-library">
<h3>Sequence library<a class="headerlink" href="#sequence-library" title="Permalink to this headline"></a></h3>
<p>For all agents is recommended to create a sequence library with some different sequences.
More sequences helps to uncover more bugs and rise coverage with small effort.
Sequence library randomly select sequence and run it on current seqeuncer.
This is repeated until sequence_library run required number of sequences.
Different sequence can randomly create different test scenarions like
burst mode, send small packet, send big packets, read or write sequently or on same address and others.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_packet_small</span> <span class="k">extends</span> <span class="n">uvm_sequence</span> <span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">example</span><span class="o">::</span><span class="n">sequence_packet_small</span><span class="p">)</span>

     <span class="k">rand</span> <span class="k">int</span> <span class="k">unsigned</span> <span class="n">transactions</span><span class="p">;</span>
        <span class="n">constraints</span> <span class="n">c_transactions</span><span class="p">{</span>
            <span class="n">transactions</span> <span class="k">inside</span> <span class="p">{[</span><span class="mh">100</span><span class="o">:</span><span class="mh">2000</span><span class="p">]};</span>
        <span class="p">}</span>

    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">sequence_item</span><span class="p">#(</span><span class="no">C_CHAR_WIDTH</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;req&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">transactions</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="n">req</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span> <span class="k">with</span> <span class="p">{</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="k">inside</span> <span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">10</span><span class="p">]};</span>
            <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_packet_large</span> <span class="k">extends</span> <span class="n">uvm_sequence</span> <span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">example</span><span class="o">::</span><span class="n">sequence_packet_large</span><span class="p">)</span>

    <span class="k">rand</span> <span class="k">int</span> <span class="k">unsigned</span> <span class="n">transactions</span><span class="p">;</span>
        <span class="n">constraints</span> <span class="n">c_transactions</span><span class="p">{</span>
            <span class="n">transactions</span> <span class="k">inside</span> <span class="p">{[</span><span class="mh">100</span><span class="o">:</span><span class="mh">2000</span><span class="p">]};</span>
        <span class="p">}</span>

    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">sequence_item</span><span class="p">#(</span><span class="no">C_CHAR_WIDTH</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;req&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">transactions</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="n">req</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span> <span class="k">with</span> <span class="p">{</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="k">inside</span> <span class="p">[</span><span class="mh">10000</span><span class="o">:</span><span class="mh">200000</span><span class="p">]};</span>
            <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>Creation of sequence library</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_lib</span> <span class="k">extends</span> <span class="n">uvm_sequence_library</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">example</span><span class="o">::</span><span class="n">sequence_lib</span><span class="p">)</span>
    <span class="no">`uvm_sequence_library_utils</span><span class="p">(</span><span class="n">example</span><span class="o">::</span><span class="n">sequence_lib</span><span class="p">)</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">init_sequence_library</span><span class="p">();</span>
    <span class="k">endfunction</span>

    <span class="c1">// subclass can redefine and change run sequences</span>
    <span class="c1">// can be useful in specific tests</span>
    <span class="k">virtual</span> <span class="k">function</span> <span class="n">init_sequence</span><span class="p">();</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">sequence_packet_large</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">sequence_packet_small</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>run in environment or test</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">env</span> <span class="k">extends</span> <span class="n">uvm_env</span>
    <span class="p">...</span>
    <span class="n">taks</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">sequence_lib</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">sequence_lib</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;sequence_lib&quot;</span><span class="p">);</span>
        <span class="n">sequence_lib</span><span class="p">.</span><span class="n">init_sequence</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sequence_lib</span><span class="p">.</span><span class="n">randomize</span><span class="p">())</span>
            <span class="no">`uvm_fatal</span> <span class="p">(...);</span>
        <span class="n">sequence_lib</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
    <span class="k">endtask</span>
    <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="package">
<h3>Package<a class="headerlink" href="#package" title="Permalink to this headline"></a></h3>
<p>In all registration macros `uvm_components_``*`` `uvm_object_``*`` is required to use class name together with package name.
<strong>`uvm_components_utils(pkg::class)</strong></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you don’t register a component with package name, the verification can instantiate wrong class and verification behavioral can act strangely.</p>
</div>
<p>The verification code should use namespaces. Do not use <strong>import pkg::``*``</strong> command until it is necessary.
The only situation where you can use it is the import of uvm_package.</p>
</section>
</section>
<section id="layered-agents">
<h2>Layered agents<a class="headerlink" href="#layered-agents" title="Permalink to this headline"></a></h2>
<p>The most of the verification tests doesn’t need to generate low level data.
For this purpose exist the high level generators which can generate packets.
This approach unifies the high level packet and separete it from from a low level protocol.
For a layered agent it is good way to use a pointer to high sequencer from low level sequence.
For this approach is required to know design pattern called <em>abstract factory</em> and how it is used in UVM methodology.</p>
<section id="environment">
<h3>Environment<a class="headerlink" href="#environment" title="Permalink to this headline"></a></h3>
<p>The environment logically groups together other environments and agents.
In this case the environment groups high and low level agents. Required steps are:
1. Registration of a new high level monitor which completes a high level transaction from the low level transactions.
2. Creating a low level sequence which pulls high level sequence items from high level sequencer and generate low level transactions from high level sequence items
3. Use the second argument when creating sequence or sequence_library because it simplify run specific sequence for specific tests.</p>
<img alt="layered agents" class="align-center" src="comp/uvm/docs/layered_agents.svg" /><div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">env</span> <span class="k">extends</span> <span class="n">uvm_env</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="c1">//change common monitor to specific monitor</span>
        <span class="n">byte_array_moinitor</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">set_inst_override</span><span class="p">(</span><span class="n">byte_array_mfb_monitor</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="n">get_full_name</span><span class="p">(),</span> <span class="s">&quot;.m_byte_array_agent.*&quot;</span><span class="p">});</span>
        <span class="k">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
        <span class="n">m_byte_array_agent</span> <span class="o">=</span> <span class="n">byte_array_agent</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_byte_array_agent&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="n">m_mfb_agent</span>        <span class="o">=</span> <span class="n">mfb_agent</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_mfb_agent&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">byte_array_mfb_monitor</span> <span class="n">mon</span><span class="p">;</span>
        <span class="n">$cast</span><span class="p">(</span><span class="n">mon</span><span class="p">,</span> <span class="n">m_byte_array_agent</span><span class="p">.</span><span class="n">m_monitor</span><span class="p">);</span>
        <span class="n">m_mfb_agent</span><span class="p">.</span><span class="n">analysis_port</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">mon</span><span class="p">.</span><span class="n">analysis_imp</span><span class="p">);</span>
        <span class="n">analysis_port</span> <span class="o">=</span> <span class="n">m_byte_array_agent</span><span class="p">.</span><span class="n">m_monitor</span><span class="p">.</span><span class="n">analysis_port</span><span class="p">;</span>
        <span class="n">m_sequencer</span>   <span class="o">=</span> <span class="n">m_byte_array_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">;</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="c1">// It is recomended use sequence library</span>
        <span class="n">byte_array_mfb_sequence</span> <span class="n">seq</span><span class="p">;</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">byte_array_mfb_sequence</span><span class="o">::</span><span class="n">type_ide</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;seq&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="n">seq</span><span class="p">.</span><span class="n">hl_sequencer</span> <span class="o">=</span> <span class="n">m_byte_array_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">;</span>
        <span class="k">forever</span> <span class="k">begin</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">randomize</span><span class="p">();</span>
            <span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">m_mfb_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="low-level-sequence">
<h3>Low level sequence<a class="headerlink" href="#low-level-sequence" title="Permalink to this headline"></a></h3>
<p>The purpose of low-level sequence is to create low level sequence_items from high-level sequence_item. For example we use byte array as high level sequence_item and 32bit word as low level transaction.
Folowing example shows how to parse the high level items into the low level items using the for cycle. Low level sequence is going to be run in environment in the <em>run_phase</em> task as show previous example.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">task</span> <span class="n">body</span><span class="p">()</span>
    <span class="k">forever</span> <span class="k">begin</span>
        <span class="c1">//get higher level transactin from higher level sequencer</span>
        <span class="n">hl_sequencer</span><span class="p">.</span><span class="n">get_next_item</span><span class="p">(</span><span class="n">hl_item</span><span class="p">);</span>
        <span class="c1">//break hl_item into lower level transaction</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">hl_item</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">it</span> <span class="o">+=</span> <span class="no">WORD_SIZE</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
            <span class="n">req</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&lt;&lt;</span> <span class="mh">8</span><span class="p">{</span><span class="n">hl_item</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">it</span> <span class="o">+:</span> <span class="no">WORD_SIZE</span><span class="p">]}};</span>
            <span class="n">req</span><span class="p">.</span><span class="n">sof</span> <span class="o">=</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
            <span class="n">req</span><span class="p">.</span><span class="n">eof</span> <span class="o">=</span> <span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span>
                <span class="n">req</span><span class="p">.</span><span class="n">sof</span> <span class="o">=</span> <span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="no">WORD_SIZE</span> <span class="o">&gt;=</span> <span class="n">hl_item</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">req</span><span class="p">.</span><span class="n">eof</span> <span class="o">=</span> <span class="mh">1</span><span class="mb">&#39;b1</span>
            <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="c1">//send item done to higher level sequencer</span>
        <span class="n">hl_sequencer</span><span class="p">.</span><span class="n">item_done</span><span class="p">();</span>
    <span class="k">end</span>
<span class="n">endtaks</span>
</pre></div>
</div>
</section>
<section id="high-level-monitor">
<h3>High level monitor<a class="headerlink" href="#high-level-monitor" title="Permalink to this headline"></a></h3>
<p>The purpose of high level monitor is to create a high level sequence_item from a low level sequence_items.
Unfortunately the general high level monitor cannot cooperate with low level transaction.
Therefore the common approach is to reimplement a high level monitor and use UVM configuration database as shows the previous example. Important is the <em>build_phase</em> and <em>connection_phase</em> task.
The function <em>build_phase</em> shows how to use the reimplemented monitor with the UVM configuration database. Function <em>connect_phase</em> shows how to connect a low level monitor to a high level monitor.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">byte_array_mfb_monitor</span> <span class="k">extends</span> <span class="n">byte_array</span><span class="o">::</span><span class="n">monitor</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">virtual</span> <span class="k">function</span> <span class="k">void</span> <span class="n">write</span><span class="p">(</span><span class="n">ll_transaction</span> <span class="n">tr</span><span class="p">);</span>
        <span class="c1">// start of hl transaction</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">sof</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">fifo_data</span><span class="p">.</span><span class="n">delete</span><span class="p">();</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">ll_transaction</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">DATA_WIDTH</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">fifo_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">[(</span><span class="n">it</span> <span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">*</span><span class="mh">8</span><span class="o">-</span><span class="mh">1</span> <span class="o">-:</span> <span class="mh">8</span><span class="p">]);</span>
        <span class="k">end</span>
        <span class="c1">// end of hl transaction</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">eof</span><span class="p">)</span> <span class="k">begin</span>
           <span class="n">item</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">fifo_data</span>
           <span class="n">analysis_port</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>
    <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="id2">
<h3>Configuration object<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h3>
<p>An enviroment create configuration object for his subenviroments or containing agents.
Folowing example shows how to create two configuration objects for agents which are instaintiate in current environment.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">env</span> <span class="k">extends</span> <span class="n">uvm_env</span>
    <span class="p">...</span>
    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">byte_array_cfg</span> <span class="n">m_byte_array_cfg</span><span class="p">;</span>
        <span class="n">mfb_cfg</span>        <span class="n">m_mfb_cfg</span><span class="p">;</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="n">byte_array_mfb_cfg</span><span class="p">)</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;m_config&quot;</span><span class="p">,</span> <span class="n">m_config</span><span class="p">);</span>
        <span class="c1">//save config object for subcomponent</span>
        <span class="n">m_byte_array_cfg</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
        <span class="n">m_byte_array_cfg</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">m_config</span><span class="p">.</span><span class="n">active</span><span class="p">;</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="n">byte_array_cfg</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;m_byte_array_agent&quot;</span><span class="p">,</span> <span class="s">&quot;m_config&quot;</span><span class="p">,</span> <span class="n">m_byte_array_cfg</span><span class="p">);</span>
        <span class="n">m_mfb_cfg</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
        <span class="n">m_mfb_cfg</span><span class="p">.</span><span class="n">active</span>   <span class="o">=</span> <span class="n">m_config</span><span class="p">.</span><span class="n">active</span><span class="p">;</span>
        <span class="n">m_mfb_cfg</span><span class="p">.</span><span class="n">vif_name</span> <span class="o">=</span> <span class="n">m_config</span><span class="p">.</span><span class="n">vif_name</span><span class="p">;</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="n">mfb_cfg</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">&quot;m_mfb_agent&quot;</span><span class="p">,</span> <span class="s">&quot;m_config&quot;</span><span class="p">,</span> <span class="n">m_mfb_cfg</span><span class="p">);</span>
        <span class="c1">//create subcomponent</span>
        <span class="n">m_byte_array</span> <span class="o">=</span> <span class="n">byte_array</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_byte_array&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="n">m_mfb_agent</span>  <span class="o">=</span> <span class="n">mfb_agent</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_mfb_agent&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>
    <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
<img alt="configuration object" class="align-center" src="comp/uvm/docs/cofiguration_object.svg" /></section>
<section id="id3">
<h3>Sequence library<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h3>
<p>It is recommended to use a sequence library as a lower sequnece. It is going to have better coverage.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_library</span> <span class="k">extends</span> <span class="n">uvm_sequence_library</span><span class="p">;</span>
   <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">byte_array_mfb</span><span class="o">::</span><span class="n">sequence_library</span><span class="p">)</span>
   <span class="no">`uvm_sequence_library_utils</span><span class="p">(</span><span class="n">byte_array_mfb</span><span class="o">::</span><span class="n">sequence_library</span><span class="p">)</span>
    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">init_sequence_library</span><span class="p">();</span>
    <span class="k">endfunction</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="n">init_sequence</span><span class="p">();</span>
        <span class="c1">//run only this sequence</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_small</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_mid</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_rand_spaces</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_constant</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_increment</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_large</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
   <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="run-of-the-specific-sequence">
<h3>Run of the specific sequence<a class="headerlink" href="#run-of-the-specific-sequence" title="Permalink to this headline"></a></h3>
<p>This example shows how to run a specific sequence on lower sequencer in environment from test.</p>
<p>create new sequence_library</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_lib</span> <span class="k">extends</span> <span class="n">byte_array_mfb</span><span class="o">::</span><span class="n">sequence_library</span><span class="p">;</span>
   <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_lib</span><span class="p">)</span>
   <span class="no">`uvm_sequence_library_utils</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_lib</span><span class="p">)</span>
    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">init_sequence_library</span><span class="p">();</span>
    <span class="k">endfunction</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="n">init_sequence</span><span class="p">();</span>
        <span class="c1">//run only this sequence</span>
        <span class="k">this</span><span class="p">.</span><span class="n">add_sequence</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">sequence_packet_large</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
   <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>Code below shows how to change the sequence library using UVM abstract factory.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">test</span> <span class="k">extends</span> <span class="n">uvm_test</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="c1">//change implementation</span>
        <span class="n">byte_array_mfb</span><span class="o">::</span><span class="n">sequence_lib</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">set_inst_override</span><span class="p">(</span><span class="n">sequence_lib</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="n">get_full_name</span><span class="p">()</span> <span class="p">,</span><span class="s">&quot;.m_env.rx_agent*&quot;</span><span class="p">});</span>
        <span class="p">...</span>
        <span class="c1">//create environment with change</span>
        <span class="n">m_env</span> <span class="o">=</span> <span class="n">component</span><span class="o">::</span><span class="n">env</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_env&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
</section>
<section id="common-environment">
<h2>Common environment<a class="headerlink" href="#common-environment" title="Permalink to this headline"></a></h2>
<p>Environment (uvm_env) puts together agents, subenvironments and others components into a logical unit.
Common use of the environmet is connect high level agent with low level agent. Picture below shows
environment with two agents, one environment and one virtual sequencer.</p>
<img alt="environment" class="align-center" src="comp/uvm/docs/enviroment.svg" /><section id="virtual-sequencer">
<h3>Virtual sequencer<a class="headerlink" href="#virtual-sequencer" title="Permalink to this headline"></a></h3>
<p>Virtual sequencer connects all highest level sequencers into one sequencer. On that sequencer runs a virtual seqeunce.
If the environment contains other environment like on previous picture, virtual sequencer consist only of highest sequencer from subenvironment.</p>
<img alt="virtual sequencer" class="align-center" src="comp/uvm/docs/virtual_sequencer.svg" /><div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequencer</span> <span class="k">extends</span> <span class="n">uvm_sequencer</span><span class="p">;</span>
    <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">env</span><span class="o">::</span><span class="n">sequencer</span><span class="p">)</span>

    <span class="n">mfb</span><span class="o">::</span><span class="n">sequencer</span> <span class="n">m_mfb_sequencer</span><span class="p">;</span>
    <span class="n">mvb</span><span class="o">::</span><span class="n">sequencer</span> <span class="n">m_mvb_sequencer</span><span class="p">;</span>
    <span class="k">config</span><span class="o">::</span><span class="n">sequencer</span> <span class="n">m_config_sequencer</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_simple</span> <span class="k">extends</span> <span class="n">uvm_sequence</span><span class="p">;</span>
    <span class="no">`uvm_object_param_utils</span><span class="p">(</span><span class="n">env</span><span class="o">::</span><span class="n">sequence_simple</span><span class="p">)</span>
    <span class="no">`uvm_declare_p_sequencer</span><span class="p">(</span> <span class="n">env</span><span class="o">::</span><span class="n">sequencer</span> <span class="p">)</span>

    <span class="c1">//sequence define</span>
    <span class="n">mfb</span><span class="o">::</span><span class="n">sequence_simple</span> <span class="n">mfb_sequence</span><span class="p">;</span>
    <span class="n">mvm</span><span class="o">::</span><span class="n">sequence_simple</span> <span class="n">mvb_sequence</span><span class="p">;</span>
    <span class="k">config</span><span class="o">::</span><span class="n">sequence_simple</span> <span class="n">config_sequence</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
        <span class="k">fork</span>
            <span class="no">`uvm_do_on</span><span class="p">(</span><span class="n">mfb_sequence</span><span class="p">,</span> <span class="n">p_sequencer</span><span class="p">.</span><span class="n">m_mfb_sequencer</span><span class="p">);</span>
            <span class="no">`uvm_do_on</span><span class="p">(</span><span class="n">mvb_sequence</span><span class="p">,</span> <span class="n">p_sequencer</span><span class="p">.</span><span class="n">m_mvb_sequencer</span><span class="p">);</span>
            <span class="no">`uvm_do_on</span><span class="p">(</span><span class="n">config_sequence</span><span class="p">,</span> <span class="n">p_sequencer</span><span class="p">.</span><span class="n">m_config_sequencer</span><span class="p">);</span>
        <span class="k">join</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="scoreboard">
<h3>Scoreboard<a class="headerlink" href="#scoreboard" title="Permalink to this headline"></a></h3>
<p>Scoreboard simply connects the DUT and compares transaction expected from a model and transaction gained from the DUT.
It is appropriate to implement the <em>report_phase</em> which prints some statistics at the end of simulation to inform the user how depth verification was.
It is good practice to write uniform text such as <em>VERIFICATION SUCCESS</em> when verification ends successfully, which can be useful in some automatic testing tools such as <em>Jenkins</em>.</p>
<p>Verification should check if the design haven’t stuck.
For example the DUT can set all <em>rdy</em> signals to zero and don’t change them until the end of verification.
This means that no packet goes through design and it should be reported by verification.</p>
<p>Model should be implemented in a indepedent class. Example below shows how should Scoreboard and Model cooperate. Scoreboard only check equality of each transaction.
if transaction isn’t same then the socreboard print error message through macro UVM_error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>macro UVM_error dosn’t stop verificatin. On end of simulation the Scoreboard have to check if some errors ocurre in verification.</p>
</div>
<img alt="scoreboard" class="align-center" src="comp/uvm/docs/scoreboard.svg" /><div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">scoreboard</span> <span class="n">uvm_scoreboard</span><span class="p">;</span>
    <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">env</span><span class="o">::</span><span class="n">scoreboard</span><span class="p">)</span>
    <span class="c1">//CONNECT DUT</span>
    <span class="n">uvm_analysis_export</span> <span class="p">#(</span><span class="n">packet</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">analysis_export_rx</span><span class="p">;</span>
    <span class="n">uvm_analysis_export</span> <span class="p">#(</span><span class="n">packet</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">analysis_export_tx</span><span class="p">;</span>
    <span class="c1">//output fifos</span>
    <span class="n">uvm_tlm_analysis_fifo</span> <span class="p">#(</span><span class="n">packet</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">model_fifo</span><span class="p">;</span>
    <span class="n">uvm_tlm_analysis_fifo</span> <span class="p">#(</span><span class="n">packet</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">dut_fifo</span><span class="p">;</span>
    <span class="c1">//models</span>
    <span class="n">model</span> <span class="n">m_model</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_coponent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
      <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
      <span class="n">analysis_export_rx</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">&quot;analysis_imp_rx&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="n">analysis_export_tx</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">&quot;analysis_imp_tx&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="n">model_fifo</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">&quot;model_fifo&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="n">dut_fifo</span>   <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="s">&quot;dut_fifo&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">analysis_export_rx</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m_model</span><span class="p">.</span><span class="k">input</span><span class="p">.</span><span class="n">anlysis_export</span><span class="p">);</span>
        <span class="n">analysis_export_tx</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dut_fifo</span><span class="p">.</span><span class="n">analysis_export</span><span class="p">);</span>
        <span class="n">m_model</span><span class="p">.</span><span class="k">output</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">model_fifo</span><span class="p">.</span><span class="n">analysis_export</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">run_phase</span><span class="p">();</span>
        <span class="k">forever</span> <span class="k">begin</span>
            <span class="n">model_fifo</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr_model</span><span class="p">);</span>
            <span class="n">dut_fifo</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr_dut</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tr_model</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">tr_dut</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span> <span class="k">begin</span>
                <span class="no">`uvm_error</span><span class="p">(...);</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">endtask</span>

    <span class="k">virtual</span> <span class="k">function</span> <span class="k">void</span> <span class="n">report_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">success</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dut_output</span><span class="p">.</span><span class="n">used</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">&amp;&amp;</span> <span class="n">model_output</span><span class="p">.</span><span class="n">used</span><span class="p">()</span> <span class="o">==</span><span class="mh">0</span><span class="p">)</span> <span class="k">begin</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">---------------------------------------</span><span class="se">\n\t</span><span class="s">----     VERIFICATION SUCCESS      ----</span><span class="se">\n\t</span><span class="s">---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
        <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">---------------------------------------</span><span class="se">\n\t</span><span class="s">----     VERIFICATION FAIL      ----</span><span class="se">\n\t</span><span class="s">---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
</section>
<section id="request-response-agents">
<h2>Request response Agents<a class="headerlink" href="#request-response-agents" title="Permalink to this headline"></a></h2>
<p>Some agents may require bidirectional comunications.
For this purpose the UVM has the Request response mechanism.</p>
<p>For example the read request on MI has two transaction.
The first transaction is master and the second transaction is slave.</p>
<img alt="question response" class="align-center" src="../../_images/MI_agent.svg" /></section>
<section id="reset">
<h2>Reset<a class="headerlink" href="#reset" title="Permalink to this headline"></a></h2>
<section id="monitor">
<h3>Monitor<a class="headerlink" href="#monitor" title="Permalink to this headline"></a></h3>
</section>
<section id="sequencer-and-sequence">
<h3>Sequencer and sequence<a class="headerlink" href="#sequencer-and-sequence" title="Permalink to this headline"></a></h3>
</section>
<section id="model">
<h3>Model<a class="headerlink" href="#model" title="Permalink to this headline"></a></h3>
</section>
</section>
<section id="coverage">
<h2>Coverage<a class="headerlink" href="#coverage" title="Permalink to this headline"></a></h2>
<p>Coverage is one of important metrics for checking verification status. Coverage can tell if the verification of design is done properly.
Every verification should check if coverage is high enought if not verification designer should explain why is not.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">output_cover</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">)</span> <span class="k">extends</span> <span class="n">uvm_subscriber</span><span class="p">#(</span><span class="n">seqeunce_item</span><span class="p">);</span>
    <span class="no">`uvm_component_param_utils</span><span class="p">(</span><span class="n">packet_port_env</span><span class="o">::</span><span class="n">output_cover</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">))</span>
    <span class="n">sequence_item</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">covergroup</span> <span class="n">cov_packet</span><span class="p">;</span>
        <span class="n">items_size</span> <span class="o">:</span> <span class="k">coverpoint</span> <span class="n">item</span><span class="p">.</span><span class="n">packet</span><span class="p">.</span><span class="n">data</span> <span class="p">{</span>
            <span class="k">bins</span> <span class="n">num</span><span class="p">[</span><span class="mh">512</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mh">0</span><span class="o">:</span><span class="mh">2</span><span class="o">**</span><span class="mh">16</span><span class="o">-</span><span class="mh">1</span><span class="p">]};</span>
            <span class="k">illegal_bins</span> <span class="n">others</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">items_port</span> <span class="o">:</span> <span class="k">coverpoint</span> <span class="n">item</span><span class="p">.</span><span class="n">port</span> <span class="p">{</span>
            <span class="k">bins</span> <span class="n">num</span><span class="p">[</span><span class="no">OUTPUTS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mh">0</span><span class="o">:</span><span class="no">OUTPUTS</span><span class="o">-</span><span class="mh">1</span><span class="p">]};</span>
            <span class="k">illegal_bins</span> <span class="n">others</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">cross</span> <span class="n">items_size</span><span class="p">,</span> <span class="n">items_port</span><span class="p">;</span>
    <span class="k">endgroup</span>
    <span class="p">...</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">write</span><span class="p">(</span><span class="n">sequence_item</span> <span class="n">tr</span><span class="p">);</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">tr</span><span class="p">;</span>
        <span class="n">cov_packet</span><span class="p">.</span><span class="n">sample</span><span class="p">();</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
<section id="functional-coverage">
<h3>Functional coverage<a class="headerlink" href="#functional-coverage" title="Permalink to this headline"></a></h3>
<p>Every model should contains functional coverage to check if all of the funcionality was tested.
Functional coverage can be measured in model.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">coverage_base</span> <span class="k">extends</span>  <span class="n">uvm_subscriber</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="n">sequence_item</span> <span class="n">item</span><span class="p">;</span>
    <span class="k">covergroup</span> <span class="n">m_cov</span><span class="p">;</span>
        <span class="nl">ones:</span> <span class="k">coverpoint</span> <span class="n">$countones</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">mash</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">bins</span> <span class="n">ones</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{[</span><span class="mh">0</span><span class="o">:</span><span class="mh">20</span><span class="p">]};</span>
        <span class="p">}</span>
    <span class="k">endgroup</span>

    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="n">m_cov</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">write</span><span class="p">(</span><span class="n">sequence_item</span> <span class="n">t</span><span class="p">);</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">m_cov</span><span class="p">.</span><span class="n">sample</span><span class="p">();</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="code-coverage">
<h3>Code coverage<a class="headerlink" href="#code-coverage" title="Permalink to this headline"></a></h3>
<p>Code coverage represents how many lines, conditional jumps and expression the test checks.</p>
<p>A simple metric is mostly generated by verification tool.
In the OFM verification environment can be set up by adding <em>set SIM_FLAGS(CODE_COVERAGE) “true”</em> into file <em>top_level.fdo</em>.</p>
<section id="generating-coverage-reports">
<h4>Generating coverage reports<a class="headerlink" href="#generating-coverage-reports" title="Permalink to this headline"></a></h4>
<p>ModelSim can generate coverage reports into HTML:</p>
<ul class="simple">
<li><p><em>coverage report -html -output cov_html -instance=/testbench/DUT_U -source -details -assert -directive -cvg -code bcefst -verbose -threshL 50 -threshH 90</em></p></li>
</ul>
<p>Merge more report from one simulation. Next commands is for our multiver script.
After every simulation is coverage save into actual.ucdb. Next command merge coverage from
actual simulation with all earlest simulation. Last command generate html output.</p>
<ul class="simple">
<li><p><em>coverage save -assert -directive -cvg -code bcefst -verbose actual.ucdb-</em></p></li>
<li><p><em>vcover merge final.ucdb final.ucdb actual.ucdb</em></p></li>
<li><p><em>vcover report -html -output cov_html -instance=/testbench/DUT_U -source -details -assert -directive -cvg -code bcefst -verbose -threshL 50 -threshH 90 final.ucdb</em></p></li>
</ul>
</section>
</section>
</section>
<section id="verification-example">
<h2>Verification example<a class="headerlink" href="#verification-example" title="Permalink to this headline"></a></h2>
<p>Let say we have component MFB splitter which divide MFB stream into N output streams. With every incoming packet to mfb, also came information about output port.
Output ports is send on MVB interface. For simplified verification MVB interface is not aligned to MFB. Use method FIFO. It is only depend on ordering MFB and MVB streams.</p>
<p>The image show block connection of such verification.</p>
<img alt="Verification connection" class="align-center" src="comp/uvm/docs/mfb_splitter.svg" /><section id="byte-array-port-environment">
<h3>Byte_array_port environment<a class="headerlink" href="#byte-array-port-environment" title="Permalink to this headline"></a></h3>
<p>Environment is used for grouping byte_array and port. Advantage of this solution is generating data for MVB and MFB in one roll.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_item</span> <span class="n">extend</span> <span class="n">uvm_sequence_item</span><span class="p">;</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequnece_item</span><span class="p">)</span>
    <span class="k">rand</span> <span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span> <span class="n">packet</span><span class="p">;</span>
    <span class="k">rand</span> <span class="k">int</span> <span class="k">unsigned</span>              <span class="n">port</span><span class="p">;</span>
    <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>Because is required to divide high level sequence, we cannot use pointer directly to high level sequencer. So we use driver to divide sequence into two piece</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">driver</span> <span class="k">extends</span> <span class="n">uvm_driver</span><span class="p">#(</span><span class="n">sequence_item</span><span class="p">);</span>
  <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">drivere</span><span class="p">)</span>
   <span class="n">mailbox</span> <span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">msg_byte_array</span><span class="p">;</span>
   <span class="n">mailbox</span> <span class="p">#(</span><span class="k">int</span> <span class="k">unsigned</span><span class="p">)</span>              <span class="n">msg_port</span><span class="p">;</span>

   <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
       <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
       <span class="n">msg_byte_array</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="mh">10</span><span class="p">);</span> <span class="c1">//max 10 requests</span>
       <span class="n">msg_port</span>       <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="mh">10</span><span class="p">);</span>
   <span class="k">endfunction</span>

   <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
       <span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span> <span class="n">tr_paket</span><span class="p">;</span>
       <span class="k">int</span> <span class="k">unsigned</span>              <span class="n">tr_port</span><span class="p">;</span>
       <span class="k">forever</span> <span class="k">begin</span>
           <span class="n">seq_item_port</span><span class="p">.</span><span class="n">get_next_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
           <span class="n">tr_paket</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">paket</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
           <span class="n">msg_byte_array</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">tr_paket</span><span class="p">);</span>
           <span class="n">tr_port</span>  <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
           <span class="n">msg_port</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">tr_port</span><span class="p">);</span>
           <span class="n">seq_item_port</span><span class="p">.</span><span class="n">item_done</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
       <span class="k">end</span>
   <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>Environment contains two sequences. One generate <em>byte_array::sequence_item</em>. Second generate <em>mvb::sequence_item</em>.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_byte_array</span> <span class="k">extends</span> <span class="n">uvm_sequnece</span><span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequence_byte_array</span><span class="p">)</span>
     <span class="n">mailbox</span> <span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">in_data</span><span class="p">;</span>
     <span class="p">...</span>
     <span class="n">taks</span> <span class="n">body</span><span class="p">();</span>
         <span class="k">forever</span> <span class="k">begin</span>
             <span class="n">in_data</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
             <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
             <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
         <span class="k">end</span>
     <span class="n">endtaks</span>
<span class="k">endclass</span>
</pre></div>
</div>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">sequence_mvb</span> <span class="k">extends</span> <span class="n">uvm_sequnece</span><span class="p">#(</span><span class="n">mvb</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">);</span>
    <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequence_mvb</span><span class="p">)</span>
     <span class="n">mailbox</span> <span class="p">#(</span><span class="k">int</span> <span class="k">unsigned</span><span class="p">)</span> <span class="n">in_data</span><span class="p">;</span>
     <span class="p">...</span>
     <span class="n">taks</span> <span class="n">body</span><span class="p">();</span>
         <span class="n">req</span> <span class="o">=</span> <span class="n">mvb</span><span class="o">::</span><span class="n">sequence_item</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;byte_array_port_env::mvb&quot;</span><span class="p">);</span>
         <span class="k">int</span> <span class="k">unsigned</span> <span class="n">mvb_valid_items</span><span class="p">;</span>
         <span class="k">forever</span> <span class="k">begin</span>
             <span class="k">bit</span> <span class="n">rdy</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>
             <span class="n">start_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
             <span class="n">req</span><span class="p">.</span><span class="n">randomize</span><span class="p">();</span>
             <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">REGIONS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">vld</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">==</span> <span class="mh">1</span> <span class="o">&amp;&amp;</span> <span class="n">in_data</span><span class="p">.</span><span class="n">num</span><span class="p">()</span> <span class="o">!=</span> <span class="mh">0</span><span class="p">)</span> <span class="k">begin</span>
                      <span class="n">rdy</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
                      <span class="n">in_data</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">it</span><span class="p">]);</span>
                  <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
                       <span class="n">req</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="m">&#39;x</span>
                  <span class="k">end</span>
             <span class="k">end</span>
             <span class="n">req</span><span class="p">.</span><span class="n">rdy</span> <span class="o">&amp;=</span> <span class="n">rdy</span><span class="p">;</span>
             <span class="n">finish_item</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
         <span class="k">end</span>
     <span class="n">endtaks</span>
<span class="k">endclass</span>
</pre></div>
</div>
<p>Next code shows how to put all together.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">env</span> <span class="k">extends</span> <span class="n">uvm_env</span><span class="p">;</span>
    <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">env</span><span class="p">)</span>
    <span class="n">sequencer</span> <span class="n">m_sequencer</span><span class="p">;</span>
    <span class="n">driver</span>    <span class="n">m_driver</span><span class="p">;</span>
    <span class="n">monitor</span>   <span class="n">m_monitor</span><span class="p">;</span>
    <span class="c1">//low level agents</span>
    <span class="n">byte_array_mfb</span><span class="o">::</span><span class="n">agent</span> <span class="n">byte_array_agent</span><span class="p">;</span>
    <span class="n">mvb</span><span class="o">::</span><span class="n">agent</span>            <span class="n">mvb_agent</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
       <span class="n">sequence_byte_array</span> <span class="n">seq_byte_array</span><span class="p">;</span>
       <span class="n">sequence_mvb</span>        <span class="n">seq_mvb</span><span class="p">;</span>
       <span class="n">seq_byte_array</span> <span class="o">=</span> <span class="n">sequence_byte_array</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;sequence_byte_array&quot;</span><span class="p">);</span>
       <span class="n">seq_byte_array</span><span class="p">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="n">m_driver</span><span class="p">.</span><span class="n">msg_byte_array</span><span class="p">;</span>
       <span class="n">seq_mvb</span>        <span class="o">=</span> <span class="n">sequence_mvb</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;sequence_mvb&quot;</span><span class="p">);</span>
       <span class="n">seq_mvb</span><span class="p">.</span><span class="n">in_data</span> <span class="o">=</span> <span class="n">m_driver</span><span class="p">.</span><span class="n">msg_mvb</span><span class="p">;</span>
       <span class="k">fork</span>
           <span class="n">seq_byte_array</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">byte_array_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
           <span class="n">seq_mvb</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">mvb_agent</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
       <span class="k">join</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>Model<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h3>
<p>Inputs and outputs of the models are implemented by the transaction level model - in UVM are used the <em>uvm_analysis_</em>, <em>uvm_tm_analysis_</em> macros. Model have the same outputs and inputs as DUT.
This aproach has been chosen because the models can be easily connected together to create another model contanaining more smlaller models.</p>
<p>Sometimes is required to pass meta-informations through models. For example when we have one model composite from others models and one of the internal models can discard some data. Then we cannot
add some meta information such as time when packet enter to DUT to count delay of DUT. This information can be used to measure maximum delay of DUT.
We haven’t yet found out how to aproach this problem. One simple solution is by reimplementing all internal models but this aproach is quite time consuming.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">model</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">)</span> <span class="k">extends</span> <span class="n">uvm_component</span><span class="p">;</span>
    <span class="no">`uvm_componet_param_utils</span><span class="p">(</span><span class="n">packet_splitter</span><span class="o">::</span><span class="n">model</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">))</span>
    <span class="n">uvm_tlm_analysis_fifo</span> <span class="p">#(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span> <span class="n">analysis_imp_rx</span><span class="p">;</span>
    <span class="n">uvm_analysis_port</span>     <span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span>                 <span class="n">analysis_port_tx</span><span class="p">[</span><span class="no">PORTS</span><span class="p">];</span>

    <span class="k">function</span> <span class="k">new</span> <span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="n">analysis_imp_rx</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="s">&quot;analysis_imp_rx&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">PORTS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="k">string</span> <span class="n">it_num</span><span class="p">;</span>
            <span class="n">it_num</span><span class="p">.</span><span class="n">itoa</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="n">analysis_port_tx</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span><span class="p">({</span><span class="s">&quot;sc_output_&quot;</span><span class="p">,</span> <span class="n">it_num</span><span class="p">},</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span><span class="p">);</span>
        <span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequence_item</span> <span class="n">tr</span><span class="p">;</span>
        <span class="k">forever</span> <span class="k">begin</span>
            <span class="n">analysis_imp_rx</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr</span><span class="p">);</span>
            <span class="c1">//model write packet to output</span>
            <span class="n">analysis_port_tx</span><span class="p">[</span><span class="n">tr</span><span class="p">.</span><span class="n">port</span><span class="p">].</span><span class="n">write</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">packet</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>Scoreboard<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h3>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">soreboard</span> <span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">)</span> <span class="n">extens</span> <span class="n">uvm_scoreboard</span><span class="p">;</span>
    <span class="no">`uvm_componet_param_utils</span><span class="p">(</span><span class="n">packet_splitter</span><span class="o">::</span><span class="n">scoreboard</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">))</span>
    <span class="c1">//INPUT FROM DUT</span>
    <span class="n">uvm_analysis_export</span><span class="p">#(</span><span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span> <span class="n">analysis_export_rx_packet</span><span class="p">;</span>
    <span class="n">uvm_analysis_export</span><span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequence_item</span><span class="p">)</span>          <span class="n">analysis_export_tx_packet</span><span class="p">[</span><span class="no">PORTS</span><span class="p">];</span>
    <span class="c1">//OUTPUT TO SCOREBOARD</span>
    <span class="n">uvm_tlm_analysis_fifo</span><span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequnece_item</span><span class="p">)</span> <span class="n">dut_output</span><span class="p">[</span><span class="no">PORTS</span><span class="p">];</span>
    <span class="n">uvm_tlm_analysis_fifo</span><span class="p">#(</span><span class="n">byte_array</span><span class="o">::</span><span class="n">sequnece_item</span><span class="p">)</span> <span class="n">model_output</span><span class="p">[</span><span class="no">PORTS</span><span class="p">];</span>
    <span class="c1">//internal components</span>
    <span class="n">packet_splitter</span><span class="o">::</span><span class="n">model</span> <span class="p">#(</span><span class="no">PORTS</span><span class="p">)</span> <span class="n">m_model</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
        <span class="n">analysis_export_rx_packet</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="s">&quot;analysis_export_rx_packet&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">PORTS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="k">string</span> <span class="n">it_num</span><span class="p">;</span>
            <span class="n">it_num</span><span class="p">.</span><span class="n">itoa</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="n">analysis_export_tx_packet</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span><span class="p">({</span><span class="s">&quot;analysis_export_tx_packet_&quot;</span><span class="p">,</span> <span class="n">it_num</span><span class="p">},</span> <span class="k">this</span><span class="p">);</span>
            <span class="n">dut_output</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>                <span class="o">=</span> <span class="k">new</span><span class="p">({</span><span class="s">&quot;dut_output_&quot;</span><span class="p">,</span> <span class="n">it_num</span><span class="p">},</span> <span class="k">this</span><span class="p">);</span>
            <span class="n">model_output</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>              <span class="o">=</span> <span class="k">new</span><span class="p">({</span><span class="s">&quot;model_output_&quot;</span><span class="p">,</span> <span class="n">it_num</span><span class="p">},</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">m_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">::</span><span class="n">packet_splitter</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_model&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">analysis_export_rx_packet</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">m_model</span><span class="p">.</span><span class="n">analysis_imp_rx</span><span class="p">.</span><span class="n">analysis_export</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">PORTS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
             <span class="n">analysis_export_tx_packet</span><span class="p">[</span><span class="n">it</span><span class="p">].</span><span class="n">connect</span><span class="p">(</span><span class="n">dut_output</span><span class="p">[</span><span class="n">it</span><span class="p">].</span><span class="n">analysis_export</span><span class="p">);</span>
             <span class="n">m_model</span><span class="p">.</span><span class="n">analysis_port_tx</span><span class="p">[</span><span class="n">it</span><span class="p">].</span><span class="n">connect</span><span class="p">(</span><span class="n">model_output</span><span class="p">[</span><span class="n">it</span><span class="p">].</span><span class="n">analysis_export</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">run_phase_port</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">,</span> <span class="n">intunsigned</span> <span class="n">port</span><span class="p">);</span>
        <span class="k">forever</span> <span class="k">begin</span>
            <span class="n">dut_output</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr_out</span><span class="p">);</span>
            <span class="n">model_output</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr_model</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tr_out</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">tr_model</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">1</span><span class="p">)</span>
                <span class="no">`uvm_error</span><span class="p">(...);</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
         <span class="k">fork</span><span class="p">...</span>
            <span class="n">run_phase_port</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
         <span class="k">join</span>
    <span class="k">endtask</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">report_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="c1">//print statistics</span>
        <span class="n">m_model</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">sucess</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dut_output</span><span class="p">.</span><span class="n">used</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">&amp;&amp;</span> <span class="n">model_output</span><span class="p">.</span><span class="n">used</span><span class="p">()</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span> <span class="k">begin</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;----     VERIFICATION SUCCESS      ----&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
        <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;----     VERIFICATION FAIL         ----&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
            <span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span> <span class="s">&quot;---------------------------------------&quot;</span><span class="p">,</span> <span class="no">UVM_NONE</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="test-environment">
<h3>Test environment<a class="headerlink" href="#test-environment" title="Permalink to this headline"></a></h3>
<p>After creating model and scoreboard we assembly test environment <em>env</em>. We need environment <em>byte_array_port</em> which we created earlier and environment <em>byte_array_mfb</em>
which is store in <em>OMF:comp/uvm/byte_array_mfb</em>. It is requred to put correct path to file <em>Modules.tcl</em></p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">env</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">)</span> <span class="k">extends</span> <span class="n">uvm_env</span><span class="p">;</span>
    <span class="no">`uvm_componet_param_utils</span><span class="p">(</span><span class="n">packet_splitter</span><span class="o">::</span><span class="n">env</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">))</span>
    <span class="c1">//rx agents</span>
    <span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">env</span>             <span class="n">rx_env</span><span class="p">;</span>
    <span class="c1">//tx agent</span>
    <span class="n">byte_aray_mfb</span><span class="o">::</span><span class="n">tx_env_base</span><span class="p">#(</span><span class="no">REGIONS</span><span class="p">)</span> <span class="n">tx_env</span><span class="p">[</span><span class="no">PORTS</span><span class="p">];</span>
    <span class="c1">//scoreboard</span>
    <span class="n">scoreboard</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">)</span> <span class="n">sc</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">rx_env</span> <span class="o">=</span> <span class="n">byte_array_port_env</span><span class="o">::</span><span class="n">env</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;rx_env&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">PORTS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="k">string</span> <span class="n">it_num</span><span class="p">;</span>
            <span class="n">it_num</span><span class="p">.</span><span class="n">itoa</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="n">tx_env</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte_aray_mfb</span><span class="o">::</span><span class="n">tx_env_base</span><span class="p">#(</span><span class="no">REGIONS</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">({</span><span class="s">&quot;tx_env_&quot;</span><span class="p">,</span> <span class="n">it_num</span><span class="p">},</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">scoreboard</span><span class="p">#(</span><span class="no">PORTS</span><span class="p">,</span> <span class="no">REGIONS</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;sc&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">connect_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">rx_env</span><span class="p">.</span><span class="n">analysis_port</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">analysis_export_rx_packet</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="k">unsigned</span> <span class="n">it</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="no">PORTS</span><span class="p">;</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
            <span class="n">tx_env</span><span class="p">[</span><span class="n">it</span><span class="p">].</span><span class="n">m_byte_array</span><span class="p">.</span><span class="n">analysis_port</span><span class="p">(</span><span class="n">sc</span><span class="p">.</span><span class="n">analysis_export_tx_packet</span><span class="p">[</span><span class="n">it</span><span class="p">]);</span>
        <span class="k">end</span>
    <span class="k">endfunction</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="test">
<h3>Test<a class="headerlink" href="#test" title="Permalink to this headline"></a></h3>
<p>Test runs the highest level seqeunce and create specific adjustment to verification environment. For some tests we want to generate full speed traffic for mfb without any
interframe and between frame spaces. This adjustmens is add by UVM abstract factory. If you wish to see example looking for <em>sequence library</em> on this page.</p>
<p>example of full speed mfb sequence</p>
<p>Test example</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">base</span> <span class="k">extends</span> <span class="n">uvm_test</span>
    <span class="no">`uvm_componet_utils</span><span class="p">(</span><span class="n">test</span><span class="o">::</span><span class="n">base</span><span class="p">)</span>
    <span class="n">packet_splitter</span><span class="o">::</span><span class="n">env_main</span><span class="p">#(</span><span class="mh">8</span><span class="p">,</span> <span class="mh">2</span><span class="p">)</span> <span class="n">m_env</span><span class="p">;</span>

    <span class="k">function</span> <span class="k">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">uvm_component</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">null</span><span class="p">);</span>
        <span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
        <span class="n">m_env</span> <span class="o">=</span> <span class="n">packet_splitter</span><span class="o">::</span><span class="n">env_main</span><span class="p">#(</span><span class="mh">8</span><span class="p">,</span><span class="mh">2</span><span class="p">)</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;m_env&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="k">endfunction</span>

    <span class="k">task</span> <span class="n">run_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
         <span class="n">test</span><span class="o">::</span><span class="n">sequence_rx</span>     <span class="n">seq_rx_pacet</span><span class="p">;</span>
         <span class="n">test</span><span class="o">::</span><span class="n">sequence_tx_rdy</span> <span class="n">seq_tx_rdy</span><span class="p">;</span>
         <span class="n">phase</span><span class="p">.</span><span class="n">raise_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
         <span class="k">fork</span>
            <span class="no">`uvm_do</span><span class="p">(</span><span class="n">seq_rx_packet</span><span class="p">,</span> <span class="n">m_env</span><span class="p">.</span><span class="n">rx_env</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
            <span class="no">`uvm_do</span><span class="p">(</span><span class="n">seq_tx_rdy</span><span class="p">,</span>    <span class="n">m_env</span><span class="p">.</span><span class="n">tx_env</span><span class="p">.</span><span class="n">m_sequencer</span><span class="p">);</span>
         <span class="k">join_any</span>
         <span class="n">phase</span><span class="p">.</span><span class="n">drop_objection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">endtask</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="id6">
<h3>Properties<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h3>
<p>Properties contains interface protocols rules which have to DUT keep. Also it can contain some other DUT properties.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span> <span class="n">mfb_splitter_properties</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">)</span> <span class="p">(</span><span class="k">logic</span> <span class="no">CLK</span><span class="p">,</span> <span class="n">reset_if</span> <span class="no">RESET</span><span class="p">,</span> <span class="n">mfb_if</span> <span class="no">RX_MFB</span><span class="p">,</span> <span class="n">mvb_if</span> <span class="no">RX_MFB</span><span class="p">,</span> <span class="n">mfb_if</span> <span class="no">TX_MFB</span><span class="p">[</span><span class="no">OUTPUTS</span><span class="p">]);</span>
    <span class="n">mfb_propeties</span> <span class="p">(</span>
         <span class="p">.</span><span class="no">CLK</span>   <span class="p">(</span><span class="no">CLK</span><span class="p">),</span>
         <span class="p">.</span><span class="no">RESET</span> <span class="p">(</span><span class="no">RESET</span><span class="p">),</span>
         <span class="p">.</span><span class="no">MFB</span>   <span class="p">(</span><span class="no">RX_MFB</span><span class="p">)</span>
      <span class="p">);</span>

    <span class="n">mvb_properties</span> <span class="p">(</span>
         <span class="p">.</span><span class="no">CLK</span>   <span class="p">(</span><span class="no">CLK</span><span class="p">),</span>
         <span class="p">.</span><span class="no">RESET</span> <span class="p">(</span><span class="no">RESET</span><span class="p">),</span>
         <span class="p">.</span><span class="no">MVB</span>   <span class="p">(</span><span class="no">RX_MVB</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="c1">// you can add some properties if you want.</span>
<span class="k">endmodule</span>
</pre></div>
</div>
</section>
<section id="testbench">
<h3>testbench<a class="headerlink" href="#testbench" title="Permalink to this headline"></a></h3>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">testbench</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">);</span>
    <span class="k">logic</span> <span class="no">CLK</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>

    <span class="n">reset_if</span>                                               <span class="n">rst</span><span class="p">(</span><span class="no">CLK</span><span class="p">);</span>
    <span class="n">mvb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">MVB_ITEM_WIDTH</span><span class="p">)</span>                      <span class="n">rx_mvb</span><span class="p">(</span><span class="no">CLK</span><span class="p">);</span>
    <span class="n">mfb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">REGION_SIZE</span><span class="p">,</span> <span class="no">BLOCK_SIZE</span><span class="p">,</span> <span class="no">ITEM_WIDTH</span><span class="p">)</span> <span class="n">rx_mfb</span><span class="p">(</span><span class="no">CLK</span><span class="p">);</span>
    <span class="n">mfb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">REGION_SIZE</span><span class="p">,</span> <span class="no">BLOCK_SIZE</span><span class="p">,</span> <span class="no">ITEM_WIDTH</span><span class="p">)</span> <span class="n">tx_mfb</span><span class="p">[</span><span class="no">OUTPUTS</span><span class="p">](</span><span class="no">CLK</span><span class="p">);</span>

    <span class="c1">// create clock</span>
    <span class="k">always</span> <span class="p">#(</span><span class="no">CLK_PERIOD</span><span class="p">)</span> <span class="no">CLK</span> <span class="o">=</span> <span class="o">~</span><span class="no">CLK</span><span class="p">;</span>

    <span class="c1">// Start of tests</span>
    <span class="k">initial</span> <span class="k">begin</span>
        <span class="k">virtual</span> <span class="n">mfb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">REGION_SIZE</span><span class="p">,</span> <span class="no">BLOCK_SIZE</span><span class="p">,</span> <span class="no">ITEM_WIDTH</span><span class="p">)</span> <span class="n">v_tx_mfb</span><span class="p">;</span>
        <span class="n">v_tx_mfb</span> <span class="o">=</span> <span class="n">tx_mfb</span><span class="p">;</span>
        <span class="c1">// Configuration TX</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">OUTPUTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="k">begin</span>
            <span class="k">string</span> <span class="n">i_string</span><span class="p">;</span>
            <span class="n">i_string</span><span class="p">.</span><span class="n">itoa</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">virtual</span> <span class="n">mfb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">REGION_SIZE</span><span class="p">,</span> <span class="no">BLOCK_SIZE</span><span class="p">,</span> <span class="no">ITEM_WIDTH</span><span class="p">))</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;OUTPUT_MFB_&quot;</span><span class="p">,</span><span class="n">i_string</span><span class="p">},</span> <span class="n">v_mfb_tx</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">end</span>
        <span class="c1">// save pointer to interface into configuration database</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">virtual</span> <span class="n">mfb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">REGION_SIZE</span><span class="p">,</span> <span class="no">BLOCK_SIZE</span><span class="p">,</span> <span class="no">ITEM_WIDTH</span><span class="p">))</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;INPUT_MFB&quot;</span><span class="p">,</span> <span class="n">rx_mfb</span><span class="p">);</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">virtual</span> <span class="n">mvb_if</span> <span class="p">#(</span><span class="no">REGIONS</span><span class="p">,</span> <span class="no">MVB_ITEM_WIDTH</span><span class="p">))</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;INPUT_MVB&quot;</span><span class="p">,</span> <span class="n">rx_mfb</span><span class="p">);</span>
        <span class="n">uvm_config_db</span><span class="p">#(</span><span class="k">virtual</span> <span class="n">reset_if</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;RESET&quot;</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
        <span class="n">run_test</span><span class="p">();</span>
    <span class="k">end</span>

    <span class="c1">// DUT modul</span>
    <span class="no">DUT</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">)</span> <span class="no">DUT_U</span> <span class="p">(</span>
      <span class="p">.</span><span class="no">CLK</span>    <span class="p">(</span><span class="no">CLK</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RESET</span>  <span class="p">(</span><span class="n">rst</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RX_MFB</span> <span class="p">(</span><span class="n">rx_mfb</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RX_MVB</span> <span class="p">(</span><span class="n">rx_mvb</span><span class="p">),</span>
      <span class="p">.</span><span class="no">TX_MFB</span> <span class="p">(</span><span class="n">mfb</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// check of properties</span>
    <span class="no">MFB_SPLITTER_PROPERTIES</span> <span class="p">#(</span><span class="no">OUTPUTS</span><span class="p">)</span> <span class="no">PRT</span> <span class="p">(</span>
      <span class="p">.</span><span class="no">CLK</span>   <span class="p">(</span><span class="no">CLK</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RESET</span>  <span class="p">(</span><span class="n">rst</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RX_MFB</span> <span class="p">(</span><span class="n">rx_mfb</span><span class="p">),</span>
      <span class="p">.</span><span class="no">RX_MVB</span> <span class="p">(</span><span class="n">rx_mvb</span><span class="p">),</span>
      <span class="p">.</span><span class="no">TX_MFB</span> <span class="p">(</span><span class="n">mfb</span><span class="p">)</span>
    <span class="p">);</span>
<span class="k">endmodule</span>
</pre></div>
</div>
</section>
</section>
<section id="notes">
<h2>NOTES<a class="headerlink" href="#notes" title="Permalink to this headline"></a></h2>
<section id="uvm-error-vs-uvm-fatal">
<h3>UVM_error vs UVM_fatal<a class="headerlink" href="#uvm-error-vs-uvm-fatal" title="Permalink to this headline"></a></h3>
<p>Difference between macros UVM_error and UVM_fatal is in meaning.
Macro UVM_fatal represents error in verification environment. For example when agent cannot find an interface.</p>
<p>The macro UVM_error should be used for reporting errors in DUT, for example when the output transaction doesn’t match expected transaction.</p>
<p>For better readability messages written by macro follow folowing rules:
#. On start of string print new line with tabulator <em>“nttext”</em>
#. After a new line is required put one or more tabulator depend on indentation.
#. Don’t write new line on end of text. UVM macros automatically add new line on the end of string.</p>
</section>
<section id="parametrized-object">
<h3>Parametrized object<a class="headerlink" href="#parametrized-object" title="Permalink to this headline"></a></h3>
<p>If you need a parametrised uvm_object or uvm_component then use registration macros <em>uvm_component_param_utils</em> and <em>uvm_object_param_utils</em>.
Parametrised object can be required when some interface has parametrised signal width.</p>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">non_parametrized_class</span> <span class="k">extends</span> <span class="n">uvm_object</span><span class="p">;</span>
    <span class="no">`uvm_object_utils</span><span class="p">#(</span><span class="n">pkg</span><span class="o">::</span><span class="n">non_parametrized_class</span><span class="p">);</span>

     <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">parametrized_class</span><span class="p">#(</span><span class="no">PARAM</span><span class="p">)</span> <span class="k">extends</span> <span class="n">uvm_object</span><span class="p">;</span>
    <span class="no">`uvm_object_param_utils</span><span class="p">#(</span><span class="n">pkg</span><span class="o">::</span><span class="n">non_parametrized_class</span><span class="p">#(</span><span class="no">PARAM</span><span class="p">));</span>

    <span class="k">logic</span> <span class="p">[</span><span class="no">PARAM</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">val</span><span class="p">;</span>
     <span class="p">...</span>
<span class="k">endclass</span>
</pre></div>
</div>
</section>
<section id="synchronization">
<h3>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline"></a></h3>
<p>For synchronization in the UVM exists the uvm_event class. The uvm_event class provides more functionality such as standard barier in SystemVerilog.
Also there is a uvm_pool which provides access to uvm_barier using name.</p>
</section>
</section>
<section id="ofm-verification-environment">
<h2>OFM verification environment<a class="headerlink" href="#ofm-verification-environment" title="Permalink to this headline"></a></h2>
<p>When you create new agent you can inspirate yourself by <a class="reference external" href="https://gitlab.liberouter.org/ndk/ofm/-/tree/devel/comp/uvm/mfb">MVB agent</a>.
All classes which are related to one agent or environment should be placed in one directory.
All files are included by a package.
In this directory should exists a Modules.tcl file which includes pkg.sv, interface.sv if required and all required packages.
If the interface is bidirectional then all files with uvm_component should contain two classes: agent_rx and agent_tx.
See the MI interface as an example for bidirectional and pipelined interface.
Also the slave side has to be able to respond in the same clock cycle as request occurs (this is not implemented).</p>
<img alt="interface direction" class="align-center" src="comp/uvm/docs/interface_direction.svg" /><section id="modules-tcl">
<h3>Modules.tcl<a class="headerlink" href="#modules-tcl" title="Permalink to this headline"></a></h3>
<p>This file is written in TCL language.
The file contains required files and required dependencies for package.
Following command adds a package which will be compiled first.
Common use can add math_pkg.sv which contain common mathematical function.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nb">lappend</span> PACKAGES <span class="s2">&quot;$ENTITY_BASE/math_pack.vhd&quot;</span>
</pre></div>
</div>
<p>Folowing command add two required commponent <em>SH_REG</em> and <em>FIFOX</em>. Component <em>SH_REG</em> is in directory <em>OFM_PATH/comp/base/shreg/sh_reg_base</em> and load architecture <em>FULL</em>.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nb">lappend</span> COMPONETS <span class="k">[</span> <span class="nb">list</span> <span class="s2">&quot;SH_REG&quot;</span>      <span class="nv">$OFM_PATH</span><span class="o">/</span>comp<span class="o">/</span>base<span class="o">/</span>shreg<span class="o">/</span>sh_reg_base       <span class="s2">&quot;FULL&quot;</span> <span class="k">]</span>
<span class="nb">lappend</span> COMPONETS <span class="k">[</span> <span class="nb">list</span> <span class="s2">&quot;FIFOX&quot;</span>       <span class="nv">$OFM_PATH</span><span class="o">/</span>comp<span class="o">/</span>base<span class="o">/</span>fifo<span class="o">/</span>fifox              <span class="s2">&quot;FULL&quot;</span> <span class="k">]</span>
</pre></div>
</div>
<p>Two file <em>./arch.vhd</em> and <em>ent.vhd</em> contain VHDL design. Following command load this two files.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nb">lappend</span> MOD <span class="s2">&quot;$ENTITY_BASE/arch.vhd&quot;</span>
<span class="nb">lappend</span> MOD <span class="s2">&quot;$ENTITY_BASE/ent.vhd&quot;</span>
</pre></div>
</div>
</section>
<section id="main-fdo-script-for-running-the-verification">
<h3>Main .fdo script for running the verification<a class="headerlink" href="#main-fdo-script-for-running-the-verification" title="Permalink to this headline"></a></h3>
<p>This file is typically named top_level.fdo.
Basically contains the COMPONENT variable, which hold typically two items:
the first component is the verified design (DUT), and the second component is the verification environment.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nb">lappend</span> COMPONETS <span class="k">[</span><span class="nb">list</span> <span class="s2">&quot;DUT&quot;</span>  <span class="nv">$DUT_BASE</span>  <span class="s2">&quot;FULL&quot;</span><span class="k">]</span>
<span class="nb">lappend</span> COMPONETS <span class="k">[</span><span class="nb">list</span> <span class="s2">&quot;VER&quot;</span>  <span class="nv">$VER_BASE</span>  <span class="s2">&quot;FULL&quot;</span><span class="k">]</span>
</pre></div>
</div>
<p>You can suppress warnings printed by the numeric_std or the std_logic_arith library.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using of the std_logic_arith is discouraged.</p>
</div>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="c">#Suppress warnings from arith library</span>
<span class="nb">puts</span> <span class="s2">&quot;Numeric Std Warnings - Disabled&quot;</span>
<span class="k">set</span> NumericStdNoWarnings <span class="mi">1</span>
<span class="nb">puts</span> <span class="s2">&quot;Std Arith Warnings - Disabled&quot;</span>
<span class="k">set</span> StdArithNoWarnings <span class="mi">1</span>
</pre></div>
</div>
<p>Folowing command add some extra parametr to vsim. last parametr <em>+UVM_MAX_QUIT_COUNT=X</em> stop verification after <em>X</em> UVM_errors occure.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="k">set</span> SIM_FLAGS<span class="k">(</span><span class="nv">EXTRA_VFLAGS</span><span class="k">)</span> <span class="s2">&quot;+UVM_TESTNAME=test::base -uvmcontrol=all +UVM_MAX_QUIT_COUNT=1&quot;</span>
</pre></div>
</div>
<p>This command loads the OFM build environment, compiles the sources for simulation and runs the simulation with vsim:</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> <span class="s2">&quot;$FIRMWARE_BASE/build/Modelsim.inc.fdo&quot;</span>
</pre></div>
</div>
<p>Now you can run the verification by passing the .fdo file name to the <cite>vsim -do</cite> command. You can also run the verification in command line (without GUI) with the switch -c:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>vsim -do top_level.fdo -c
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../../ver.html" class="btn btn-neutral float-left" title="Verifications" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="byte_array/readme.html" class="btn btn-neutral float-right" title="Byte Array agent" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, CESNET z.s.p.o..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>