<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MI Transaction Controler (MTC) &mdash; OFM User Guide 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="PTC (PCIe Transaction Controller)" href="../ptc/readme.html" />
    <link rel="prev" title="PCIe Tools" href="../../../pcie.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> OFM User Guide
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Build system:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../build/readme.html">Build System</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Components:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../base.html">Basic Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ctrls.html">Controllers &amp; TSU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fl.html">FL Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flu.html">FLU Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mi.html">MI Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mfb.html">MFB Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mvb.html">MVB Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nic.html">Network Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../pcie.html">PCIe Tools</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">MI Transaction Controler (MTC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptc/readme.html">PTC (PCIe Transaction Controller)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptc/comp/tag_manager/readme.html">PTC Tag Manager</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../debug.html">Debug Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ver.html">Verifications</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packages:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../base/pkg/readme.html">Packages</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OFM User Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../pcie.html">PCIe Tools</a> &raquo;</li>
      <li>MI Transaction Controler (MTC)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/comp/pcie/mtc/readme.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mi-transaction-controler-mtc">
<span id="mtc"></span><h1>MI Transaction Controler (MTC)<a class="headerlink" href="#mi-transaction-controler-mtc" title="Permalink to this headline"></a></h1>
<dl class="vhdl autoentity">
<dt class="sig sig-object vhdl" id="vhdl-entity-mtc">
<span class="k"><span class="pre">ENTITY</span> </span><span class="sig-name descname"><span class="pre">MTC</span></span><span class="k"> <span class="pre">IS</span></span><a class="headerlink" href="#vhdl-entity-mtc" title="Permalink to this definition"></a></dt>
<dd><p>The MI Transaction Controler (MTC) component serves as the MI master endpoint.
It provides the conversion of PCIe read and write requests to MI requests. It
processes the responses to MI requests and sends them to the host PC as PCIe
completion transactions. If the MI slave does not respond to an MI read
request, the MTC module will be stuck, the PCIe communication will be broken
and the guest PC may get into an unexpected state.</p>
<p><strong>Simple block diagram including wiring:</strong></p>
<a class="reference internal image-reference" href="../../../_images/mtc.drawio.svg"><img alt="../../../_images/mtc.drawio.svg" class="align-center" src="../../../_images/mtc.drawio.svg" width="100%" /></a>
<p>MTC supports various FPGA models from different vendors. For Xilinx
UltraScale+ FPGAs, the AXI bus (CQ+CC) is used to connect to PCIe Hard IP.
For Intel FPGAs (Stratix 10 and Agilex), <a class="reference internal" href="../../mfb_tools/readme.html#mfb-bus"><span class="std std-ref">the MFB bus</span></a> (CQ+CC)
is used, which is connected to the PCIe Hard IP through a connection block.
Each supported PCIe Hard IP has different requirements and you need to be
familiar with their documentation, Intel R-Tile PCIe Hard IP, for example,
requires additional logic to ensure PCIe credits are handled.</p>
<span class="sig-name descname">Generics</span><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Generic</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even" id="vhdl-genconstant-mtc-axi_data_width"><td><p>AXI_DATA_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>512</p></td>
<td><p>AXI bus: width of data word in bits</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-axi_cquser_width"><td><p>AXI_CQUSER_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>183</p></td>
<td><p>AXI bus: width of CQ user word in bits</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-axi_ccuser_width"><td><p>AXI_CCUSER_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>81</p></td>
<td><p>AXI bus: width of CC user word in bits</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mfb_regions"><td><p>MFB_REGIONS</p></td>
<td><p>natural</p></td>
<td><p>2</p></td>
<td><p>MFB bus: number of regions in word</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-mfb_region_size"><td><p>MFB_REGION_SIZE</p></td>
<td><p>natural</p></td>
<td><p>1</p></td>
<td><p>MFB bus: number of blocks in region, must be 1</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mfb_block_size"><td><p>MFB_BLOCK_SIZE</p></td>
<td><p>natural</p></td>
<td><p>8</p></td>
<td><p>MFB bus: number of items in block, must be 8</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-mfb_item_width"><td><p>MFB_ITEM_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>MFB bus: width of one item in bits, must be 32 (dword)</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mfb_cq_meta_width"><td><p>MFB_CQ_META_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>3+32+128</p></td>
<td><p>MFB bus: width of CQ meta item in bits (BAR index + PCIe Prefix + PCIe Header)</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-mfb_cc_meta_width"><td><p>MFB_CC_META_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32+128</p></td>
<td><p>MFB bus: width of CQ meta item in bits (PCIe Prefix + PCIe Header)</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mfb_region_width"><td><p>MFB_REGION_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>MFB_REGION_SIZE*MFB_BLOCK_SIZE*MFB_ITEM_WIDTH</p></td>
<td><p>MFB bus: width of single data region in bits, auxiliary parameter, do not change value!</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-bar0_base_addr"><td><p>BAR0_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”01000000”</p></td>
<td><p>BAR0 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-bar1_base_addr"><td><p>BAR1_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”02000000”</p></td>
<td><p>BAR1 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-bar2_base_addr"><td><p>BAR2_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”03000000”</p></td>
<td><p>BAR2 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-bar3_base_addr"><td><p>BAR3_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”04000000”</p></td>
<td><p>BAR3 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-bar4_base_addr"><td><p>BAR4_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”05000000”</p></td>
<td><p>BAR4 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-bar5_base_addr"><td><p>BAR5_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”06000000”</p></td>
<td><p>BAR5 base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-exp_rom_base_addr"><td><p>EXP_ROM_BASE_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>X”0A000000”</p></td>
<td><p>Expansion ROM base address for PCIE-&gt;MI32 transalation</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-cc_pipe"><td><p>CC_PIPE</p></td>
<td><p>boolean</p></td>
<td><p>true</p></td>
<td><p>Enable Pipe component on CC interface</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-cq_pipe"><td><p>CQ_PIPE</p></td>
<td><p>boolean</p></td>
<td><p>true</p></td>
<td><p>Enable Pipe component on CQ interface</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mi_pipe"><td><p>MI_PIPE</p></td>
<td><p>boolean</p></td>
<td><p>true</p></td>
<td><p>Enable Pipe component on MI32 interface</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-mi_data_width"><td><p>MI_DATA_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>MI bus: width of data word in bits, must be 32.</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-mi_addr_width"><td><p>MI_ADDR_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>MI bus: width of address word in bits, must be 32.</p></td>
</tr>
<tr class="row-even" id="vhdl-genconstant-mtc-device"><td><p>DEVICE</p></td>
<td><p>string</p></td>
<td><p>“ULTRASCALE”</p></td>
<td><p>Select correct FPGA device: “ULTRASCALE”, “STRATIX10”, “AGILEX”</p></td>
</tr>
<tr class="row-odd" id="vhdl-genconstant-mtc-endpoint_type"><td><p>ENDPOINT_TYPE</p></td>
<td><p>string</p></td>
<td><p>“H_TILE”</p></td>
<td><p>Intel PCIe endpoint type (Intel only): “H_TILE”, “P_TILE”, “R_TILE”</p></td>
</tr>
</tbody>
</table>
<span class="sig-name descname">Ports</span><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Port</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Mode</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even" id="vhdl-portsignal-mtc-clk"><td><p>CLK</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>Clock signal for the whole MTC module.
Must be used clock from PCIe Hard IP!</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-reset"><td><p>RESET</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>Reset synchronized with CLK.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-ctl_max_payload_size"><td><p>CTL_MAX_PAYLOAD_SIZE</p></td>
<td><p>std_logic_vector(2 downto 0)</p></td>
<td><p>in</p></td>
<td><p>Maximum allowed size of completion payload: 000b = 128 bytes;
001b = 256 bytes; 010b = 512 bytes; 011b = 1024 bytes</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-ctl_bar_aperture"><td><p>CTL_BAR_APERTURE</p></td>
<td><p>std_logic_vector(5 downto 0)</p></td>
<td><p>in</p></td>
<td><p>BAR aperture value (Intel FPGA only). Defines the size of the address
space of BAR in the number of usable address bits.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_mfb_data"><td><p>CQ_MFB_DATA</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_REGION_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: data word with frames (packets)</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_mfb_meta"><td><p>CQ_MFB_META</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_CQ_META_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: meta word with metadata for each frame. In each region
from LSB: 128b PCIe Header, 32b PCIe Prefix, 3b BAR index.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_mfb_sof"><td><p>CQ_MFB_SOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: Start Of Frame (SOF) flag for each MFB region</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_mfb_eof"><td><p>CQ_MFB_EOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: End Of Frame (EOF) flag for each MFB region</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_mfb_sof_pos"><td><p>CQ_MFB_SOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1,log2(MFB_REGION_SIZE))-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: SOF position for each MFB region in MFB blocks</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_mfb_eof_pos"><td><p>CQ_MFB_EOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1,log2(MFB_REGION_SIZE*MFB_BLOCK_SIZE))-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: EOF position for each MFB region in MFB items</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_mfb_src_rdy"><td><p>CQ_MFB_SRC_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>CQ_MFB: source ready of each MFB bus</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_mfb_dst_rdy"><td><p>CQ_MFB_DST_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>CQ_MFB: destination ready of each MFB bus</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_mfb_data"><td><p>CC_MFB_DATA</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_REGION_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: data word with frames (packets)</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_mfb_meta"><td><p>CC_MFB_META</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_CC_META_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: meta word with metadata for each frame. In each region
from LSB: 128b PCIe Header, 32b PCIe Prefix.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_mfb_sof"><td><p>CC_MFB_SOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: Start Of Frame (SOF) flag for each MFB region</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_mfb_eof"><td><p>CC_MFB_EOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: End Of Frame (EOF) flag for each MFB region</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_mfb_sof_pos"><td><p>CC_MFB_SOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1,log2(MFB_REGION_SIZE))-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: SOF position for each MFB region in MFB blocks</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_mfb_eof_pos"><td><p>CC_MFB_EOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1,log2(MFB_REGION_SIZE*MFB_BLOCK_SIZE))-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: EOF position for each MFB region in MFB items</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_mfb_src_rdy"><td><p>CC_MFB_SRC_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>CC_MFB: source ready of each MFB bus</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_mfb_dst_rdy"><td><p>CC_MFB_DST_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>CC_MFB: destination ready of each MFB bus</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_axi_data"><td><p>CQ_AXI_DATA</p></td>
<td><p>std_logic_vector(AXI_DATA_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_AXI: Data word. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_axi_user"><td><p>CQ_AXI_USER</p></td>
<td><p>std_logic_vector(AXI_CQUSER_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_AXI: Set of signals with sideband information about trasferred
transaction. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_axi_last"><td><p>CQ_AXI_LAST</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>CQ_AXI: Indication of the last word of a transaction. For detailed
specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_axi_keep"><td><p>CQ_AXI_KEEP</p></td>
<td><p>std_logic_vector(AXI_DATA_WIDTH/32-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>CQ_AXI: Indication of valid data: each bit determines validity of
different Dword. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cq_axi_valid"><td><p>CQ_AXI_VALID</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>CQ_AXI: Indication of valid data: i.e. completer is ready to send a
transaction. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cq_axi_ready"><td><p>CQ_AXI_READY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>CQ_AXI: User application is ready to receive a transaction.
For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_axi_data"><td><p>CC_AXI_DATA</p></td>
<td><p>std_logic_vector(AXI_DATA_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_AXI: Data word. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_axi_user"><td><p>CC_AXI_USER</p></td>
<td><p>std_logic_vector(AXI_CCUSER_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_AXI: Set of signals with sideband information about trasferred
transaction. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_axi_last"><td><p>CC_AXI_LAST</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>CC_AXI: Indication of the last word of a transaction. For detailed
specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_axi_keep"><td><p>CC_AXI_KEEP</p></td>
<td><p>std_logic_vector(AXI_DATA_WIDTH/32-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>CC_AXI: Indication of valid data: each bit determines validity of
different Dword. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-cc_axi_valid"><td><p>CC_AXI_VALID</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>CC_AXI: Indication of valid data: i.e. completer is ready to send a
transaction. For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-cc_axi_ready"><td><p>CC_AXI_READY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>CC_AXI: User application is ready to receive a transaction.
For detailed specifications, see Xilinx PG213.</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-mi_function"><td><p>MI_FUNCTION</p></td>
<td><p>std_logic_vector(7 downto 0)</p></td>
<td><p>out</p></td>
<td><p>MI bus: PCIe function number that generated the current MI request</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-mi_dwr"><td><p>MI_DWR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>out</p></td>
<td><p>MI bus: data from master to slave (write data)</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-mi_addr"><td><p>MI_ADDR</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>out</p></td>
<td><p>MI bus: slave address</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-mi_be"><td><p>MI_BE</p></td>
<td><p>std_logic_vector(3 downto 0)</p></td>
<td><p>out</p></td>
<td><p>MI bus: byte enable</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-mi_rd"><td><p>MI_RD</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>MI bus: read request</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-mi_wr"><td><p>MI_WR</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td><p>MI bus: write request</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-mi_ardy"><td><p>MI_ARDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>MI bus: ready of slave module</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-mtc-mi_drd"><td><p>MI_DRD</p></td>
<td><p>std_logic_vector(31 downto 0)</p></td>
<td><p>in</p></td>
<td><p>MI bus: data from slave to master (read data)</p></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-mtc-mi_drdy"><td><p>MI_DRDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>MI bus: valid of MI_DRD data signal</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../../../pcie.html" class="btn btn-neutral float-left" title="PCIe Tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../ptc/readme.html" class="btn btn-neutral float-right" title="PTC (PCIe Transaction Controller)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, CESNET z.s.p.o..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>